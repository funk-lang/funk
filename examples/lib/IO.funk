data IO a = {
  unIO: a
}

trait Functor (f :: * -> *) {
  fmap: forall a b . (a -> b) -> f a -> f b
}

trait Applicative (f :: * -> *) {
  apply: forall a b . f (a -> b) -> f a -> f b
}

trait Monad (m :: * -> *) {
  return: forall a . a -> m a,
  bind: forall a b . m a -> (a -> m b) -> m b
}

instance Functor forall a . IO = {
  fmap = #fmapIO
}

instance Applicative forall a . IO = {
  apply = #applyIO
}

instance Monad forall a . IO = {
  return = #pureIO,
  bind = #bindIO
}

let wrapIO = \x -> IO { unIO = x };
let print = \x -> #print x;
let testIO = IO { unIO = "Hello from IO!" };
let identity = \x -> x;
let printTest = print "Hello from IO print wrapper!";
let printTest2 = print "Testing multiple IO actions!";

let replicateM_ = \n action -> #ifThenElse (#intEq n 0) (\_ -> #pureIO #Unit) (\_ -> #bindIO action (\_ -> replicateM_ (#intSub n 1) action));
